#!/usr/bin/env python3

import xml.etree.ElementTree as ET
import xml.dom.minidom

def print_xml_debug(xml_element, ip_address, verbose=False):
    """Print XML element for debugging purposes"""
    if not verbose:
        return
        
    print("=" * 80)
    print(f"RAW XML ELEMENT TYPE: {type(xml_element)}")
    print(f"RAW XML ROOT TAG: {xml_element.tag}")
    print("=" * 80)
    print("FULL XML CONTENT:")
    print("=" * 80)
    
    # Convert XML element to string with pretty formatting
    xml_string = ET.tostring(xml_element, encoding='unicode')
    
    # Try to pretty print it
    try:
        dom = xml.dom.minidom.parseString(xml_string)
        pretty_xml = dom.toprettyxml(indent="  ")
        # Remove empty lines
        pretty_lines = [line for line in pretty_xml.split('\n') if line.strip()]
        print('\n'.join(pretty_lines))
    except:
        # Fallback to raw XML if pretty printing fails
        print(xml_string)
    
    print("=" * 80)
    print()

def is_script_error(script_output):
    """
    Check if script output indicates an error rather than a vulnerability
    
    Args:
        script_output (str): The script output text
        
    Returns:
        bool: True if this appears to be an error, False if it's a valid result
    """
    if not script_output:
        return True  # Empty output is not useful
    
    error_indicators = [
        'ERROR',
        'SCRIPT EXECUTION FAILED',
        'script execution failed',
        'Could not',
        'Cannot',
        'Failed to',
        'Connection refused',
        'Connection timed out',
        'Network is unreachable',
        'No route to host',
        'Permission denied',
        'Operation not permitted',
        'Service detection performed',
        'Nmap done',
        'Starting Nmap',
        'Host discovery disabled',
        'All addresses will be marked'
    ]
    
    # Check for obvious error messages
    output_lower = script_output.lower().strip()
    
    for error_indicator in error_indicators:
        if error_indicator.lower() in output_lower:
            return True
    
    # Very short outputs are often not meaningful vulnerabilities
    if len(output_lower) < 10:
        return True
    
    # Check if output looks like a status message rather than vulnerability info
    status_patterns = [
        'not vulnerable',
        'no vulnerabilities',
        'not affected',
        'no issues found',
        'secure',
        'not exploitable'
    ]
    
    for pattern in status_patterns:
        if pattern in output_lower:
            return True  # These are status messages, not vulnerabilities
    
    return False

def extract_host_data(xml_element, target_ip, verbose=False):
    """
    Extract host data from XML element, filtering out error scripts
    
    Args:
        xml_element: XML Element from nmap
        target_ip (str): Target IP address to find
        verbose (bool): Enable verbose logging of filtered scripts
        
    Returns:
        list: List of tuples (port_data, script_data) with errors filtered out
    """
    results = []
    filtered_count = 0
    
    # Parse hosts from XML
    for host in xml_element.findall('.//host'):
        # Get host address
        address_elem = host.find('.//address[@addrtype="ipv4"]')
        if address_elem is None:
            continue
        
        host_ip = address_elem.get('addr')
        if host_ip != target_ip:
            continue
        
        # Parse ports and their scripts
        for port in host.findall('.//port'):
            port_number = port.get('portid')
            protocol = port.get('protocol')
            
            # Get service info
            service_elem = port.find('service')
            service_name = service_elem.get('name', 'unknown') if service_elem is not None else 'unknown'
            
            port_data = {
                'port_number': int(port_number) if port_number else None,
                'protocol': protocol,
                'service_name': service_name
            }
            
            # Parse script results for this port
            for script in port.findall('.//script'):
                script_id = script.get('id')
                script_output = script.get('output', '')
                
                # Only include vulnerability scripts
                if 'vuln' in script_id.lower() and script_output:
                    if not is_script_error(script_output):
                        script_data = {
                            'script_id': script_id,
                            'script_output': script_output,
                            'level': 'port'
                        }
                        results.append((port_data, script_data))
                    else:
                        filtered_count += 1
                        if verbose:
                            print(f"🔍 Filtered error script {script_id} on port {port_number}: {script_output[:100]}...")
        
        # Parse host-level scripts
        for script in host.findall('.//script'):
            # Skip if this script is already processed at port level
            parent_port = script.find('../../../.[@portid]')
            if parent_port is not None:
                continue
                
            script_id = script.get('id')
            script_output = script.get('output', '')
            
            # Only include vulnerability scripts
            if 'vuln' in script_id.lower() and script_output:
                if not is_script_error(script_output):
                    host_data = {
                        'port_number': None,
                        'protocol': None,
                        'service_name': 'host'
                    }
                    script_data = {
                        'script_id': script_id,
                        'script_output': script_output,
                        'level': 'host'
                    }
                    results.append((host_data, script_data))
                else:
                    filtered_count += 1
                    if verbose:
                        print(f"🔍 Filtered error script {script_id} (host-level): {script_output[:100]}...")
    
    if verbose and filtered_count > 0:
        print(f"📊 Filtered out {filtered_count} error scripts for {target_ip}")
    
    return results 