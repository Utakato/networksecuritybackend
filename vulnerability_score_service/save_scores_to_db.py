#!/usr/bin/env python3

import sys
import os
from datetime import datetime
from psycopg2.extras import execute_values

# Add the parent directory to the path to import db_module
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from db_service.connection import get_db_connection

# SQL query for creating the security_scores hypertable
CREATE_SECURITY_SCORES_TABLE = """
    CREATE TABLE IF NOT EXISTS security_scores (
        ip_address VARCHAR(50) NOT NULL,
        identity_key VARCHAR(44) NOT NULL,
        security_score INTEGER NOT NULL,
        open_ports_count INTEGER NOT NULL DEFAULT 0,
        vulnerabilities_count INTEGER NOT NULL DEFAULT 0,
        open_ports_penalty INTEGER NOT NULL DEFAULT 0,
        vulnerabilities_penalty INTEGER NOT NULL DEFAULT 0,
        base_score INTEGER NOT NULL DEFAULT 100,
        timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
"""

# SQL query for inserting security scores data
INSERT_SECURITY_SCORES_QUERY = """
    INSERT INTO security_scores (
        ip_address, identity_key, security_score, open_ports_count, 
        vulnerabilities_count, open_ports_penalty, vulnerabilities_penalty, 
        base_score, timestamp
    )
    VALUES %s
"""

def create_security_scores_table(conn):
    """
    Create the security_scores table if it doesn't exist
    
    Args:
        conn: Database connection
    """
    try:
        with conn.cursor() as cur:
            cur.execute(CREATE_SECURITY_SCORES_TABLE)
            conn.commit()
            
        # Create hypertable for TimescaleDB in separate transaction
        try:
            with conn.cursor() as cur:
                cur.execute("SELECT create_hypertable('security_scores', 'timestamp', if_not_exists => TRUE);")
                conn.commit()
        except Exception as hypertable_error:
            conn.rollback()
            print(f"Note: Hypertable setup: {hypertable_error}")
        
        # Create indexes in separate transaction
        try:
            with conn.cursor() as cur:
                cur.execute("""
                    CREATE INDEX IF NOT EXISTS idx_security_scores_lookup 
                    ON security_scores (ip_address, identity_key, timestamp DESC);
                """)
                cur.execute("""
                    CREATE INDEX IF NOT EXISTS idx_security_scores_score 
                    ON security_scores (security_score DESC, timestamp DESC);
                """)
                cur.execute("""
                    CREATE INDEX IF NOT EXISTS idx_security_scores_timestamp 
                    ON security_scores (timestamp DESC);
                """)
                conn.commit()
                print("security_scores table created/verified successfully")
        except Exception as index_error:
            conn.rollback()
            print(f"Note: Index creation: {index_error}")
            
    except Exception as e:
        print(f"Error creating security_scores table: {e}")
        conn.rollback()
        raise

def save_security_scores_to_db(scores_data, conn=None, clean_old=True):
    """
    Save security scores data to the security_scores table
    
    Args:
        scores_data (list): List of score dictionaries containing:
            - ip_address: IP address
            - identity_key: Identity key  
            - security_score: Calculated security score
            - open_ports_count: Number of open ports
            - vulnerabilities_count: Number of vulnerabilities
            - open_ports_penalty: Points deducted for open ports
            - vulnerabilities_penalty: Points deducted for vulnerabilities
            - base_score: Starting score (usually 100)
            - timestamp: Timestamp for the score
        conn: Database connection (optional, will create new if not provided)
        clean_old (bool): Whether to remove old entries before inserting new ones
    
    Returns:
        int: Number of scores saved
    """
    should_close_conn = False
    
    if conn is None:
        conn = get_db_connection()
        should_close_conn = True
    
    try:
        # Ensure table exists
        create_security_scores_table(conn)
        
        if not scores_data:
            print("No security scores to save")
            return 0
        
        # Optionally clean old entries from today
        if clean_old:
            with conn.cursor() as cur:
                for score_data in scores_data:
                    delete_query = """
                        DELETE FROM security_scores 
                        WHERE ip_address = %s 
                        AND identity_key = %s 
                        AND timestamp::date = %s::date
                    """
                    cur.execute(delete_query, (
                        score_data['ip_address'], 
                        score_data['identity_key'], 
                        score_data['timestamp']
                    ))
        
        # Prepare records for batch insert
        records = []
        for score_data in scores_data:
            records.append((
                score_data['ip_address'],
                score_data['identity_key'],
                score_data['security_score'],
                score_data['open_ports_count'],
                score_data['vulnerabilities_count'],
                score_data['open_ports_penalty'],
                score_data['vulnerabilities_penalty'],
                score_data['base_score'],
                score_data['timestamp']
            ))
        
        # Insert data using execute_values for efficiency
        with conn.cursor() as cur:
            execute_values(cur, INSERT_SECURITY_SCORES_QUERY, records)
            rows_affected = cur.rowcount
            conn.commit()
            
            print(f"Saved {rows_affected} security scores to database")
            return rows_affected
            
    except Exception as e:
        print(f"Error saving security scores to database: {e}")
        conn.rollback()
        return 0
    finally:
        if should_close_conn and conn:
            conn.close()

def get_latest_security_scores(limit=None, conn=None):
    """
    Retrieve the latest security scores from the database
    
    Args:
        limit (int): Optional limit on number of results
        conn: Database connection (optional)
    
    Returns:
        list: List of score dictionaries
    """
    should_close_conn = False
    
    if conn is None:
        conn = get_db_connection()
        should_close_conn = True
    
    try:
        with conn.cursor() as cur:
            # Get the latest score for each IP/identity combination
            query = """
                SELECT DISTINCT ON (ip_address, identity_key)
                    ip_address,
                    identity_key,
                    security_score,
                    open_ports_count,
                    vulnerabilities_count,
                    open_ports_penalty,
                    vulnerabilities_penalty,
                    base_score,
                    timestamp
                FROM security_scores 
                ORDER BY ip_address, identity_key, timestamp DESC
            """
            
            if limit:
                query += f" LIMIT {limit}"
            
            cur.execute(query)
            results = cur.fetchall()
            
            scores = []
            for row in results:
                scores.append({
                    'ip_address': row[0],
                    'identity_key': row[1],
                    'security_score': row[2],
                    'open_ports_count': row[3],
                    'vulnerabilities_count': row[4],
                    'open_ports_penalty': row[5],
                    'vulnerabilities_penalty': row[6],
                    'base_score': row[7],
                    'timestamp': row[8]
                })
            
            return scores
            
    except Exception as e:
        print(f"Error retrieving security scores from database: {e}")
        return []
    finally:
        if should_close_conn and conn:
            conn.close()

def main():
    """
    Test function for database operations
    """
    # Test database connection and table creation
    conn = get_db_connection(verbose=True)
    if conn:
        create_security_scores_table(conn)
        print("✅ Database tables created successfully")
        
        # Test retrieving existing scores
        scores = get_latest_security_scores(limit=5, conn=conn)
        print(f"Found {len(scores)} existing security scores")
        
        conn.close()
    else:
        print("❌ Failed to connect to database")

if __name__ == "__main__":
    main() 