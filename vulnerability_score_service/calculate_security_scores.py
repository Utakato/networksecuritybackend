#!/usr/bin/env python3

import sys
import os
from datetime import datetime
from psycopg2.extras import execute_values

# Add the parent directory to the path to import db_module
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from db_service.connection import get_db_connection

# SQL query for creating the security_scores hypertable
CREATE_SECURITY_SCORES_TABLE = """
    CREATE TABLE IF NOT EXISTS security_scores (
        ip_address VARCHAR(50) NOT NULL,
        identity_key VARCHAR(44) NOT NULL,
        security_score INTEGER NOT NULL,
        open_ports_count INTEGER NOT NULL DEFAULT 0,
        vulnerabilities_count INTEGER NOT NULL DEFAULT 0,
        open_ports_penalty INTEGER NOT NULL DEFAULT 0,
        vulnerabilities_penalty INTEGER NOT NULL DEFAULT 0,
        base_score INTEGER NOT NULL DEFAULT 100,
        timestamp TIMESTAMPTZ NOT NULL
    );
"""

# SQL query for inserting security scores data
INSERT_SECURITY_SCORES_QUERY = """
    INSERT INTO security_scores (
        ip_address, identity_key, security_score, open_ports_count, 
        vulnerabilities_count, open_ports_penalty, vulnerabilities_penalty, 
        base_score, timestamp
    )
    VALUES %s
"""

# Query to get latest open ports data with their timestamps
GET_LATEST_OPEN_PORTS_QUERY = """
    WITH latest_ports_per_ip AS (
        SELECT ip_address, identity_key, MAX(timestamp) as latest_timestamp
        FROM ip_open_ports 
        WHERE ip_address = %s AND identity_key = %s
        GROUP BY ip_address, identity_key
    )
    SELECT DISTINCT 
        iop.ip_address,
        iop.identity_key,
        iop.port,
        iop.protocol,
        iop.service,
        iop.timestamp
    FROM ip_open_ports iop
    INNER JOIN latest_ports_per_ip lp ON 
        iop.ip_address = lp.ip_address 
        AND iop.identity_key = lp.identity_key 
        AND iop.timestamp = lp.latest_timestamp
    WHERE iop.ip_address = %s AND iop.identity_key = %s
"""

# Query to get latest vulnerabilities data
GET_LATEST_VULNERABILITIES_QUERY = """
    WITH latest_vulns_per_ip AS (
        SELECT ip_address, identity_key, MAX(timestamp) as latest_timestamp
        FROM vulnerability_scans 
        WHERE ip_address = %s AND identity_key = %s
        GROUP BY ip_address, identity_key
    )
    SELECT 
        vs.ip_address,
        vs.identity_key,
        vs.vulnerability_id,
        vs.severity,
        vs.cvss_score,
        vs.timestamp
    FROM vulnerability_scans vs
    INNER JOIN latest_vulns_per_ip lv ON 
        vs.ip_address = lv.ip_address 
        AND vs.identity_key = lv.identity_key 
        AND vs.timestamp = lv.latest_timestamp
    WHERE vs.ip_address = %s AND vs.identity_key = %s
"""

def create_security_scores_table(conn):
    """
    Create the security_scores table if it doesn't exist
    
    Args:
        conn: Database connection
    """
    try:
        with conn.cursor() as cur:
            cur.execute(CREATE_SECURITY_SCORES_TABLE)
            conn.commit()
            
        # Create hypertable for TimescaleDB in separate transaction
        try:
            with conn.cursor() as cur:
                cur.execute("SELECT create_hypertable('security_scores', 'timestamp', if_not_exists => TRUE);")
                conn.commit()
        except Exception as hypertable_error:
            conn.rollback()
            print(f"Note: Hypertable setup: {hypertable_error}")
        
        # Create indexes in separate transaction
        try:
            with conn.cursor() as cur:
                cur.execute("""
                    CREATE INDEX IF NOT EXISTS idx_security_scores_lookup 
                    ON security_scores (ip_address, identity_key, timestamp DESC);
                """)
                cur.execute("""
                    CREATE INDEX IF NOT EXISTS idx_security_scores_score 
                    ON security_scores (security_score DESC, timestamp DESC);
                """)
                conn.commit()
                print("security_scores table created/verified successfully")
        except Exception as index_error:
            conn.rollback()
            print(f"Note: Index creation: {index_error}")
            
    except Exception as e:
        print(f"Error creating security_scores table: {e}")
        conn.rollback()
        raise

def get_latest_open_ports(ip_address, identity_key, conn):
    """
    Get the latest open ports data for a specific IP and identity
    
    Args:
        ip_address (str): IP address to query
        identity_key (str): Identity key to query
        conn: Database connection
    
    Returns:
        tuple: (open_ports_list, latest_timestamp)
    """
    try:
        with conn.cursor() as cur:
            cur.execute(GET_LATEST_OPEN_PORTS_QUERY, (ip_address, identity_key, ip_address, identity_key))
            results = cur.fetchall()
            
            if not results:
                return [], None
            
            open_ports = []
            latest_timestamp = None
            
            for row in results:
                port_info = {
                    'port': row[2],
                    'protocol': row[3],
                    'service': row[4]
                }
                open_ports.append(port_info)
                
                # All results should have the same timestamp (latest)
                if latest_timestamp is None:
                    latest_timestamp = row[5]
            
            return open_ports, latest_timestamp
            
    except Exception as e:
        print(f"Error retrieving open ports for {ip_address}: {e}")
        return [], None

def get_latest_vulnerabilities(ip_address, identity_key, conn):
    """
    Get the latest vulnerabilities data for a specific IP and identity
    
    Args:
        ip_address (str): IP address to query
        identity_key (str): Identity key to query
        conn: Database connection
    
    Returns:
        list: List of vulnerability dictionaries
    """
    try:
        with conn.cursor() as cur:
            cur.execute(GET_LATEST_VULNERABILITIES_QUERY, (ip_address, identity_key, ip_address, identity_key))
            results = cur.fetchall()
            
            vulnerabilities = []
            for row in results:
                vuln_info = {
                    'vulnerability_id': row[2],
                    'severity': row[3],
                    'cvss_score': row[4],
                    'timestamp': row[5]
                }
                vulnerabilities.append(vuln_info)
            
            return vulnerabilities
            
    except Exception as e:
        print(f"Error retrieving vulnerabilities for {ip_address}: {e}")
        return []

def calculate_security_score(open_ports, vulnerabilities, base_score=100):
    """
    Calculate security score based on open ports and vulnerabilities
    
    Args:
        open_ports (list): List of open ports
        vulnerabilities (list): List of vulnerabilities
        base_score (int): Starting score (default: 100)
    
    Returns:
        dict: Score calculation details
    """
    # Count unique open ports (by port number and protocol combination)
    unique_ports = set()
    for port in open_ports:
        unique_ports.add((port['port'], port['protocol']))
    
    open_ports_count = len(unique_ports)
    vulnerabilities_count = len(vulnerabilities)
    
    # Calculate penalties
    open_ports_penalty = open_ports_count * 5  # -5 points per unique open port
    vulnerabilities_penalty = vulnerabilities_count * 15  # -15 points per vulnerability
    
    # Calculate final score
    final_score = base_score - open_ports_penalty - vulnerabilities_penalty
    
    # Ensure score doesn't go below 0
    final_score = max(0, final_score)
    
    return {
        'security_score': final_score,
        'open_ports_count': open_ports_count,
        'vulnerabilities_count': vulnerabilities_count,
        'open_ports_penalty': open_ports_penalty,
        'vulnerabilities_penalty': vulnerabilities_penalty,
        'base_score': base_score
    }

def calculate_and_save_security_scores(ip_data_list, verbose=False, clean_old=True):
    """
    Calculate and save security scores for a list of IP addresses
    
    Args:
        ip_data_list (list): List of dictionaries with ip_address and identity_key
        verbose (bool): Enable verbose output
        clean_old (bool): Clean old entries before inserting new ones
    
    Returns:
        dict: Result summary
    """
    conn = None
    try:
        # Connect to database
        if verbose:
            print("üì° Connecting to database...")
        conn = get_db_connection(verbose=verbose)
        
        # Ensure table exists
        create_security_scores_table(conn)
        
        processed_count = 0
        scores_calculated = 0
        all_scores = []
        score_records = []
        
        for ip_data in ip_data_list:
            ip_address = ip_data['ip_address']
            identity_key = ip_data['identity_key']
            
            if verbose:
                print(f"üîç Processing {ip_address} (Identity: {identity_key[:8]}...)")
            
            # Get latest open ports and their timestamp
            open_ports, ports_timestamp = get_latest_open_ports(ip_address, identity_key, conn)
            
            # Get latest vulnerabilities
            vulnerabilities = get_latest_vulnerabilities(ip_address, identity_key, conn)
            
            # Use ports timestamp if available, otherwise current time
            score_timestamp = ports_timestamp if ports_timestamp else datetime.now()
            
            # Calculate security score
            score_info = calculate_security_score(open_ports, vulnerabilities)
            
            if verbose:
                print(f"   üìä Score: {score_info['security_score']}/100 "
                      f"(Ports: {score_info['open_ports_count']}, "
                      f"Vulns: {score_info['vulnerabilities_count']})")
            
            # Prepare record for database insert
            score_records.append((
                ip_address,
                identity_key,
                score_info['security_score'],
                score_info['open_ports_count'],
                score_info['vulnerabilities_count'],
                score_info['open_ports_penalty'],
                score_info['vulnerabilities_penalty'],
                score_info['base_score'],
                score_timestamp
            ))
            
            all_scores.append(score_info['security_score'])
            processed_count += 1
            scores_calculated += 1
        
        # Clean old entries if requested
        if clean_old and score_records:
            if verbose:
                print("üßπ Cleaning old security score entries...")
            
            with conn.cursor() as cur:
                # Delete today's entries for all processed IPs
                for record in score_records:
                    delete_query = """
                        DELETE FROM security_scores 
                        WHERE ip_address = %s 
                        AND identity_key = %s 
                        AND timestamp::date = %s::date
                    """
                    cur.execute(delete_query, (record[0], record[1], record[8]))
        
        # Insert new scores
        if score_records:
            if verbose:
                print(f"üíæ Saving {len(score_records)} security scores...")
            
            with conn.cursor() as cur:
                execute_values(cur, INSERT_SECURITY_SCORES_QUERY, score_records)
                conn.commit()
        
        # Calculate summary statistics
        if all_scores:
            average_score = sum(all_scores) / len(all_scores)
            lowest_score = min(all_scores)
            highest_score = max(all_scores)
        else:
            average_score = lowest_score = highest_score = 0
        
        return {
            'success': True,
            'total_processed': processed_count,
            'scores_calculated': scores_calculated,
            'average_score': average_score,
            'lowest_score': lowest_score,
            'highest_score': highest_score
        }
        
    except Exception as e:
        print(f"Error calculating security scores: {e}")
        if conn:
            conn.rollback()
        return {
            'success': False,
            'error': str(e),
            'total_processed': 0,
            'scores_calculated': 0
        }
    finally:
        if conn:
            conn.close()

def main():
    """
    Test function for security score calculation
    """
    # Test with a few sample IPs
    from shared_utils.data_access import get_all_ip_addresses
    
    ip_data = get_all_ip_addresses()[:5]  # Test with first 5 IPs
    
    if ip_data:
        print("üß™ Testing security score calculation...")
        result = calculate_and_save_security_scores(ip_data, verbose=True)
        print(f"Test result: {result}")
    else:
        print("‚ùå No IP data found for testing")

if __name__ == "__main__":
    main() 