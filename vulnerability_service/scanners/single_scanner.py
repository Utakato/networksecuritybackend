#!/usr/bin/env python3

import threading
import time
import uuid

# Import core modules (absolute imports from vulnerability-scanner directory)
from core.nmap_client import run_nmap_scan
from core.xml_parser import print_xml_debug, extract_host_data
from core.vulnerability_parser import parse_vulnerability_result

# Import database saving functions
from save_vulnerabilities_to_db import save_single_scan_result

# Import scan type configurations
from scanners.scan_types import get_scan_args

def scan_vulnerabilities(ip_address, scan_type='default', verbose=False):
    """
    Scan IP address for vulnerabilities using nmap scripts
    
    Args:
        ip_address (str): IP address to scan
        scan_type (str): Type of scan ('default', 'comprehensive', 'quick')
        verbose (bool): Enable verbose output
        
    Returns:
        list: List of discovered vulnerabilities
    """
    try:
        thread_name = threading.current_thread().name
        
        if verbose:
            print(f"[{thread_name}] Running vulnerability scan on {ip_address}...")
        
        # Get nmap arguments for scan type
        nmap_args = get_scan_args(scan_type)
        
        # Run nmap scan
        scan_results = run_nmap_scan(ip_address, nmap_args, verbose)

        # Print XML debug info if verbose
        print_xml_debug(scan_results, ip_address, verbose)

        # Extract host data from XML
        host_script_data = extract_host_data(scan_results, ip_address, verbose)
        
        if not host_script_data:
            if verbose:
                print(f"[{thread_name}] No scan results for {ip_address}")
            return []
        
        vulnerabilities = []
        
        # Process each port/script combination
        for port_data, script_data in host_script_data:
            script_id = script_data['script_id']
            script_output = script_data['script_output']
            
            # Parse vulnerability from script output
            vulns = parse_vulnerability_result(script_id, {'output': script_output})
            
            for vuln in vulns:
                vuln['affected_port'] = port_data['port_number']
                vuln['affected_service'] = port_data['service_name']
                vuln['protocol'] = port_data['protocol']
                vulnerabilities.append(vuln)
        
        if verbose:
            print(f"[{thread_name}] Found {len(vulnerabilities)} vulnerabilities for {ip_address}")
        
        return vulnerabilities
        
    except Exception as e:
        thread_name = threading.current_thread().name
        if verbose:
            print(f"[{thread_name}] Error scanning {ip_address}: {e}")
        return []

def scan_single_ip_vulnerabilities(ip_data, scan_type='default', verbose=False, save_to_db=True):
    """
    Scan a single IP address for vulnerabilities and return results
    
    Args:
        ip_data (dict): Dictionary containing ip_address and identity_key
        scan_type (str): Type of vulnerability scan
        verbose (bool): Enable verbose output
        save_to_db (bool): Whether to save results to database immediately
        
    Returns:
        dict: Results of the vulnerability scan
    """
    ip_address = ip_data['ip_address']
    identity_key = ip_data['identity_key']
    
    start_time = time.time()
    scan_session_id = str(uuid.uuid4())
    
    # Scan for vulnerabilities
    vulnerabilities = scan_vulnerabilities(ip_address, scan_type, verbose)
    
    scan_time = time.time() - start_time
    
    result = {
        'ip_address': ip_address,
        'identity_key': identity_key,
        'vulnerabilities': vulnerabilities,
        'scan_session_id': scan_session_id,
        'scan_time': scan_time,
        'scan_type': scan_type,
        'success': True
    }
    
    # Save to database immediately after scanning
    if save_to_db and vulnerabilities:
        try:
            thread_name = threading.current_thread().name
            if verbose:
                print(f"[{thread_name}] Saving {len(vulnerabilities)} vulnerabilities for {ip_address} to database...")
            
            # Use optimized single scan save function
            saved_count = save_single_scan_result(result)
            
            if verbose:
                print(f"[{thread_name}] Successfully saved {saved_count} vulnerabilities for {ip_address}")
                
        except Exception as e:
            thread_name = threading.current_thread().name
            if verbose:
                print(f"[{thread_name}] Error saving vulnerabilities for {ip_address} to database: {e}")
            # Don't fail the scan if database save fails
            result['db_save_error'] = str(e)
    
    return result

def scan_single_ip_vulnerabilities_no_save(ip_data, scan_type='default', verbose=False):
    """
    Scan a single IP address for vulnerabilities without saving to database
    (maintains backward compatibility)
    
    Args:
        ip_data (dict): Dictionary containing ip_address and identity_key
        scan_type (str): Type of vulnerability scan
        verbose (bool): Enable verbose output
        
    Returns:
        dict: Results of the vulnerability scan
    """
    return scan_single_ip_vulnerabilities(ip_data, scan_type, verbose, save_to_db=False) 