#!/usr/bin/env python3

from concurrent.futures import ThreadPoolExecutor, as_completed
import threading

# Import database functions
from save_vulnerabilities_to_db import create_scan_session, update_scan_session

# Import single scanner
from scanners.single_scanner import scan_single_ip_vulnerabilities

# Thread-safe counter for session updates
class ThreadSafeCounter:
    def __init__(self):
        self._value = 0
        self._lock = threading.Lock()
    
    def increment(self):
        with self._lock:
            self._value += 1
            return self._value
    
    @property
    def value(self):
        with self._lock:
            return self._value

def scan_multiple_ips_with_session(ip_list, scan_type='default', verbose=False, max_threads=10):
    """
    Scan multiple IP addresses with per-thread saving and real-time session tracking
    
    Args:
        ip_list (list): List of IP data dictionaries
        scan_type (str): Type of vulnerability scan
        verbose (bool): Enable verbose output
        max_threads (int): Maximum number of concurrent threads
        
    Returns:
        dict: Scan session information and summary results
    """
    # Create scan session
    session_id = create_scan_session(
        scan_type=scan_type,
        total_ips=len(ip_list),
        scan_parameters={'scan_type': scan_type, 'max_threads': max_threads}
    )
    
    if not session_id:
        print("Failed to create scan session")
        return {'success': False, 'error': 'Failed to create scan session'}
    
    if verbose:
        print(f"Started scan session {session_id} for {len(ip_list)} IPs with per-thread saving")
    
    # Thread-safe counters
    completed_counter = ThreadSafeCounter()
    failed_counter = ThreadSafeCounter()
    vulns_counter = ThreadSafeCounter()
    
    results = []
    results_lock = threading.Lock()
    
    def scan_with_per_thread_save(ip_data):
        """Individual thread function with immediate saving and session updates"""
        try:
            # Scan and save immediately (save_to_db=True)
            result = scan_single_ip_vulnerabilities(ip_data, scan_type, verbose, save_to_db=True)
            result['session_id'] = session_id
            
            # Update thread-safe counters
            if result['success']:
                completed_count = completed_counter.increment()
                vulns_count = vulns_counter.value + len(result.get('vulnerabilities', []))
                # Update vulnerability counter
                for _ in result.get('vulnerabilities', []):
                    vulns_counter.increment()
            else:
                failed_count = failed_counter.increment()
                completed_count = completed_counter.value
                vulns_count = vulns_counter.value
            
            # Add to results (thread-safe)
            with results_lock:
                results.append(result)
            
            # Update session in real-time for each completion
            update_scan_session(
                session_id,
                completed_ips=completed_counter.value,
                failed_ips=failed_counter.value,
                total_vulnerabilities=vulns_counter.value
            )
            
            if verbose:
                total_completed = completed_counter.value + failed_counter.value
                print(f"üîÑ Progress: {total_completed}/{len(ip_list)} IPs processed, {vulns_counter.value} vulnerabilities found")
            
            return result
            
        except Exception as e:
            failed_counter.increment()
            if verbose:
                print(f"‚ùå Failed to scan {ip_data.get('ip_address', 'unknown')}: {e}")
            
            # Update session with failure
            update_scan_session(
                session_id,
                completed_ips=completed_counter.value,
                failed_ips=failed_counter.value,
                total_vulnerabilities=vulns_counter.value
            )
            
            error_result = {
                'ip_address': ip_data.get('ip_address', 'unknown'),
                'identity_key': ip_data.get('identity_key', 'unknown'),
                'session_id': session_id,
                'success': False,
                'error': str(e)
            }
            
            with results_lock:
                results.append(error_result)
                
            return error_result

    try:
        # Execute all scans with per-thread saving
        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            future_to_ip = {executor.submit(scan_with_per_thread_save, ip_data): ip_data for ip_data in ip_list}
            
            # Wait for all to complete
            for future in as_completed(future_to_ip):
                try:
                    result = future.result()  # This will raise any exceptions from the thread
                except Exception as e:
                    if verbose:
                        print(f"‚ùå Thread execution error: {e}")
    
    except Exception as e:
        if verbose:
            print(f"‚ùå Error during batch scanning: {e}")
        
        # Mark session as failed
        update_scan_session(session_id, status='failed')
        return {
            'success': False,
            'session_id': session_id,
            'error': str(e),
            'completed_ips': completed_counter.value,
            'failed_ips': failed_counter.value
        }
    
    # Final session update
    update_scan_session(
        session_id,
        completed_ips=completed_counter.value,
        failed_ips=failed_counter.value,
        total_vulnerabilities=vulns_counter.value,
        status='completed'
    )
    
    if verbose:
        print(f"üéâ Scan session {session_id} completed with per-thread saving!")
        print(f"üìä Results: {completed_counter.value} successful, {failed_counter.value} failed, {vulns_counter.value} total vulnerabilities")
    
    return {
        'success': True,
        'session_id': session_id,
        'results': results,
        'completed_ips': completed_counter.value,
        'failed_ips': failed_counter.value,
        'total_vulnerabilities': vulns_counter.value
    } 