#!/usr/bin/env python3

import re

def parse_vulnerability_result(script_name, script_output):
    """
    Parse nmap vulnerability script output into structured data
    
    Args:
        script_name (str): Name of the nmap script
        script_output (dict): Script output from nmap
        
    Returns:
        list: List of vulnerability dictionaries (empty if no valid vulnerabilities)
    """
    vulnerabilities = []
    
    # Extract basic information
    output_text = script_output.get('output', '') if isinstance(script_output, dict) else script_output
    
    # Additional validation - check if this looks like a real vulnerability
    if not is_valid_vulnerability_output(output_text):
        return []  # Return empty list for invalid/error outputs
    
    # Default vulnerability entry
    vuln = {
        'vulnerability_id': script_name,
        'title': f"Vulnerability detected by {script_name}",
        'description': output_text,
        'severity': 'info',
        'cvss_score': None,
        'solution': '',
        'reference_urls': [],
        'script_output': output_text,
        'confidence_level': 'medium'
    }
    
    # Parse specific script outputs for better data extraction
    if 'vuln' in script_name.lower():
        # Enhanced parsing for vulnerability scripts
        if 'CVE' in output_text:
            # Extract CVE IDs
            cve_matches = re.findall(r'CVE-\d{4}-\d+', output_text)
            if cve_matches:
                vuln['vulnerability_id'] = cve_matches[0]
                vuln['reference_urls'] = [f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve}" for cve in cve_matches]
        
        # Determine severity based on keywords
        output_lower = output_text.lower()
        if any(keyword in output_lower for keyword in ['critical', 'high risk', 'severe']):
            vuln['severity'] = 'high'
        elif any(keyword in output_lower for keyword in ['medium', 'moderate']):
            vuln['severity'] = 'medium'
        elif any(keyword in output_lower for keyword in ['low', 'minor']):
            vuln['severity'] = 'low'
        elif 'vulnerable' in output_lower or 'exploit' in output_lower:
            vuln['severity'] = 'medium'
    
    # Parse SSL/TLS specific vulnerabilities
    elif 'ssl' in script_name.lower() or 'tls' in script_name.lower():
        vuln['title'] = f"SSL/TLS issue detected: {script_name}"
        if 'weak' in output_text.lower() or 'insecure' in output_text.lower():
            vuln['severity'] = 'medium'
        elif 'deprecated' in output_text.lower():
            vuln['severity'] = 'low'
    
    vulnerabilities.append(vuln)
    return vulnerabilities

def is_valid_vulnerability_output(output_text):
    """
    Validate if script output represents a real vulnerability finding
    
    Args:
        output_text (str): The script output to validate
        
    Returns:
        bool: True if this appears to be a valid vulnerability, False otherwise
    """
    if not output_text or len(output_text.strip()) < 10:
        return False
    
    output_lower = output_text.lower().strip()
    
    # Definite non-vulnerability indicators
    non_vuln_indicators = [
        'error',
        'failed',
        'could not',
        'cannot',
        'connection refused',
        'timeout',
        'unreachable',
        'permission denied',
        'not vulnerable',
        'no vulnerabilities',
        'not affected',
        'secure',
        'not exploitable',
        'service detection performed',
        'nmap done',
        'starting nmap'
    ]
    
    for indicator in non_vuln_indicators:
        if indicator in output_lower:
            return False
    
    # Positive vulnerability indicators
    vuln_indicators = [
        'vulnerable',
        'exploit',
        'cve-',
        'security issue',
        'weakness',
        'attack',
        'compromise',
        'backdoor',
        'malware',
        'disclosure',
        'injection',
        'overflow',
        'bypass'
    ]
    
    # If it has positive indicators, it's likely a vulnerability
    for indicator in vuln_indicators:
        if indicator in output_lower:
            return True
    
    # For outputs without clear indicators, be conservative
    # If it's longer than 50 characters and doesn't have negative indicators,
    # it might be a valid finding
    return len(output_text.strip()) > 50 