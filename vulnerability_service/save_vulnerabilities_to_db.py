#!/usr/bin/env python3

import sys
import os
import uuid
import json
from datetime import datetime
from psycopg2.extras import execute_values

# Add the parent directory to the path to import db_module
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from db_service.connection import get_db_connection

# SQL query to create vulnerability_scans table if it doesn't exist
CREATE_VULNERABILITY_SCANS_TABLE = """
    CREATE TABLE IF NOT EXISTS vulnerability_scans (
        id SERIAL,
        ip_address VARCHAR(50) NOT NULL,
        identity_key VARCHAR(44) NOT NULL,
        vulnerability_id VARCHAR(100) NOT NULL,
        severity VARCHAR(20) NOT NULL,
        cvss_score DECIMAL(3,1),
        title VARCHAR(500) NOT NULL,
        description TEXT,
        solution TEXT,
        reference_urls TEXT[],
        affected_service VARCHAR(100),
        affected_port INTEGER,
        script_output TEXT,
        confidence_level VARCHAR(20),
        verified BOOLEAN DEFAULT FALSE,
        scan_session_id UUID NOT NULL,
        scan_type VARCHAR(50) NOT NULL,
        timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
    
    -- Create hypertable for TimescaleDB if not already created
    SELECT create_hypertable('vulnerability_scans', 'timestamp', if_not_exists => TRUE);
    
    -- Create indexes for efficient queries
    CREATE INDEX IF NOT EXISTS idx_vulnerability_scans_lookup 
    ON vulnerability_scans (ip_address, identity_key, timestamp DESC);
    
    CREATE INDEX IF NOT EXISTS idx_vulnerability_scans_severity 
    ON vulnerability_scans (severity, cvss_score DESC, timestamp DESC);
    
    CREATE INDEX IF NOT EXISTS idx_vulnerability_scans_vuln_id 
    ON vulnerability_scans (vulnerability_id, timestamp DESC);
    
    CREATE INDEX IF NOT EXISTS idx_vulnerability_scans_session 
    ON vulnerability_scans (scan_session_id);
    
    CREATE INDEX IF NOT EXISTS idx_vulnerability_scans_id 
    ON vulnerability_scans (id, timestamp);
"""

# SQL query to create vulnerability scan sessions table
CREATE_SCAN_SESSIONS_TABLE = """
    CREATE TABLE IF NOT EXISTS vulnerability_scan_sessions (
        session_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        scan_type VARCHAR(50) NOT NULL,
        start_time TIMESTAMPTZ NOT NULL,
        end_time TIMESTAMPTZ,
        total_ips INTEGER,
        completed_ips INTEGER,
        failed_ips INTEGER,
        total_vulnerabilities INTEGER,
        scan_parameters JSONB,
        status VARCHAR(20) DEFAULT 'running'
    );
"""

# SQL query for inserting vulnerability data
INSERT_VULNERABILITIES_QUERY = """
    INSERT INTO vulnerability_scans (
        ip_address, identity_key, vulnerability_id, severity, cvss_score,
        title, description, solution, reference_urls, affected_service,
        affected_port, script_output, confidence_level, verified,
        scan_session_id, scan_type, timestamp
    )
    VALUES %s
"""

def create_vulnerability_tables(conn):
    """
    Create the vulnerability_scans and vulnerability_scan_sessions tables if they don't exist
    
    Args:
        conn: Database connection
    """
    try:
        with conn.cursor() as cur:
            cur.execute(CREATE_VULNERABILITY_SCANS_TABLE)
            cur.execute(CREATE_SCAN_SESSIONS_TABLE)
            conn.commit()
            print("Vulnerability tables created/verified successfully")
    except Exception as e:
        print(f"Note: Table creation/hypertable setup: {e}")
        conn.rollback()

def save_vulnerabilities_to_db(vulnerabilities_data, conn=None, clean_old=True):
    """
    Save vulnerability scan results to the vulnerability_scans table
    
    Args:
        vulnerabilities_data (list): List of vulnerability scan results
        conn: Database connection (optional, will create new if not provided)
        clean_old (bool): Whether to remove old entries for these IPs before inserting new ones
    
    Returns:
        int: Number of vulnerabilities saved
    """
    should_close_conn = False
    
    if conn is None:
        conn = get_db_connection()
        should_close_conn = True
    
    try:
        # Ensure tables exist
        create_vulnerability_tables(conn)
        
        if not vulnerabilities_data:
            print("No vulnerabilities to save")
            return 0
        
        # Use current timestamp for all vulnerabilities in this scan
        scan_timestamp = datetime.now()
        
        # Optionally clean old entries for these IPs from today
        if clean_old:
            with conn.cursor() as cur:
                for vuln_data in vulnerabilities_data:
                    delete_query = """
                        DELETE FROM vulnerability_scans 
                        WHERE ip_address = %s 
                        AND identity_key = %s 
                        AND timestamp::date = %s::date
                    """
                    cur.execute(delete_query, (
                        vuln_data['ip_address'], 
                        vuln_data['identity_key'], 
                        scan_timestamp
                    ))
        
        # Prepare records for batch insert
        records = []
        for vuln_data in vulnerabilities_data:
            ip_address = vuln_data['ip_address']
            identity_key = vuln_data['identity_key']
            scan_session_id = vuln_data['scan_session_id']
            scan_type = vuln_data['scan_type']
            
            for vuln in vuln_data['vulnerabilities']:
                records.append((
                    ip_address,
                    identity_key,
                    vuln['vulnerability_id'],
                    vuln['severity'],
                    vuln.get('cvss_score'),
                    vuln['title'],
                    vuln.get('description', ''),
                    vuln.get('solution', ''),
                    vuln.get('reference_urls', []),
                    vuln.get('affected_service'),
                    vuln.get('affected_port'),
                    vuln.get('script_output', ''),
                    vuln.get('confidence_level', 'medium'),
                    vuln.get('verified', False),
                    scan_session_id,
                    scan_type,
                    scan_timestamp
                ))
        
        if not records:
            print("No vulnerability records to save")
            return 0
        
        # Insert data using execute_values for efficiency
        with conn.cursor() as cur:
            execute_values(cur, INSERT_VULNERABILITIES_QUERY, records)
            rows_affected = cur.rowcount
            conn.commit()
            
            print(f"Saved {rows_affected} vulnerabilities from {len(vulnerabilities_data)} IP scans")
            return rows_affected
            
    except Exception as e:
        print(f"Error saving vulnerabilities to database: {e}")
        conn.rollback()
        return 0
    finally:
        if should_close_conn and conn:
            conn.close()

def save_single_scan_result(scan_result, conn=None):
    """
    Save a single vulnerability scan result to the database
    Optimized for individual scan saves during concurrent scanning
    
    Args:
        scan_result (dict): Single scan result dictionary
        conn: Database connection (optional, will create new if not provided)
    
    Returns:
        int: Number of vulnerabilities saved
    """
    if not scan_result or not scan_result.get('vulnerabilities'):
        return 0
    
    # Convert single result to list format expected by main function
    vulnerabilities_data = [scan_result]
    
    # Use the main function but don't clean old entries for individual saves
    # to avoid conflicts during concurrent scanning
    return save_vulnerabilities_to_db(vulnerabilities_data, conn=conn, clean_old=False)

def batch_save_scan_results(scan_results, conn=None, clean_old=True):
    """
    Save multiple vulnerability scan results to the database in one transaction
    
    Args:
        scan_results (list): List of scan result dictionaries
        conn: Database connection (optional, will create new if not provided)
        clean_old (bool): Whether to remove old entries for these IPs before inserting new ones
    
    Returns:
        int: Number of vulnerabilities saved
    """
    if not scan_results:
        return 0
    
    # Filter out results without vulnerabilities for efficiency
    results_with_vulns = [result for result in scan_results if result.get('vulnerabilities')]
    
    if not results_with_vulns:
        print("No scan results contain vulnerabilities to save")
        return 0
    
    return save_vulnerabilities_to_db(results_with_vulns, conn=conn, clean_old=clean_old)

def create_scan_session(scan_type, total_ips, scan_parameters=None, conn=None):
    """
    Create a new vulnerability scan session
    
    Args:
        scan_type (str): Type of scan being performed
        total_ips (int): Total number of IPs to scan
        scan_parameters (dict): Optional scan parameters
        conn: Database connection (optional)
    
    Returns:
        str: Session ID
    """
    should_close_conn = False
    
    if conn is None:
        conn = get_db_connection()
        should_close_conn = True
    
    try:
        create_vulnerability_tables(conn)
        
        session_id = str(uuid.uuid4())
        
        with conn.cursor() as cur:
            insert_session_query = """
                INSERT INTO vulnerability_scan_sessions 
                (session_id, scan_type, start_time, total_ips, completed_ips, 
                 failed_ips, total_vulnerabilities, scan_parameters, status)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            cur.execute(insert_session_query, (
                session_id,
                scan_type,
                datetime.now(),
                total_ips,
                0,  # completed_ips
                0,  # failed_ips
                0,  # total_vulnerabilities
                json.dumps(scan_parameters) if scan_parameters else None,
                'running'
            ))
            conn.commit()
            
            print(f"Created scan session {session_id} for {total_ips} IPs")
            return session_id
            
    except Exception as e:
        print(f"Error creating scan session: {e}")
        conn.rollback()
        return None
    finally:
        if should_close_conn and conn:
            conn.close()

def update_scan_session(session_id, completed_ips=None, failed_ips=None, 
                       total_vulnerabilities=None, status=None, conn=None):
    """
    Update a vulnerability scan session
    
    Args:
        session_id (str): Session ID to update
        completed_ips (int): Number of completed IP scans
        failed_ips (int): Number of failed IP scans
        total_vulnerabilities (int): Total vulnerabilities found
        status (str): Session status
        conn: Database connection (optional)
    """
    should_close_conn = False
    
    if conn is None:
        conn = get_db_connection()
        should_close_conn = True
    
    try:
        with conn.cursor() as cur:
            update_fields = []
            values = []
            
            if completed_ips is not None:
                update_fields.append("completed_ips = %s")
                values.append(completed_ips)
            
            if failed_ips is not None:
                update_fields.append("failed_ips = %s")
                values.append(failed_ips)
            
            if total_vulnerabilities is not None:
                update_fields.append("total_vulnerabilities = %s")
                values.append(total_vulnerabilities)
            
            if status is not None:
                update_fields.append("status = %s")
                values.append(status)
                if status in ['completed', 'failed', 'cancelled']:
                    update_fields.append("end_time = %s")
                    values.append(datetime.now())
            
            if update_fields:
                values.append(session_id)
                update_query = f"""
                    UPDATE vulnerability_scan_sessions 
                    SET {', '.join(update_fields)}
                    WHERE session_id = %s
                """
                cur.execute(update_query, values)
                conn.commit()
                
    except Exception as e:
        print(f"Error updating scan session: {e}")
        conn.rollback()
    finally:
        if should_close_conn and conn:
            conn.close()

def main():
    """
    Test function for database operations
    """
    # Test database connection and table creation
    conn = get_db_connection()
    if conn:
        create_vulnerability_tables(conn)
        print("✅ Database tables created successfully")
        conn.close()
    else:
        print("❌ Failed to connect to database")

if __name__ == "__main__":
    main() 